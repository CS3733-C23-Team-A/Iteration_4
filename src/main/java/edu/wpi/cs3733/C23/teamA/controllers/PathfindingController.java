package edu.wpi.cs3733.C23.teamA.controllers;

import edu.wpi.cs3733.C23.teamA.pathfinding.*;
import java.io.IOException;
import java.util.*;

public class PathfindingController {

  /**
   * @return a HashMap<String, Node> representing a graph, read from .csv files
   * @throws IOException if the files cannot be read
   */
  public static HashMap<String, Node> prepGraph() throws IOException {
    // create a graph to hold the L1 information
    HashMap<String, Node> graph = new HashMap<>();

    // add the L1 CSV information to the graph (TO BE UPDATED LATER)
    CSVReader.readNodes("src/main/resources/edu/wpi/cs3733/C23/teamA/mapCSV/L1Nodes.csv", graph);
    CSVReader.readEdges("src/main/resources/edu/wpi/cs3733/C23/teamA/mapCSV/L1Edges.csv", graph);

    return graph;
  }

  /**
   * @param graph a HashMap<String, Node> (normally) generated by prepDFS() from reading .csv files
   * @param startNodeID the ID of the node where the user wants to start from
   * @param endNodeID the ID of the node that the user wants to get to
   * @return the path between startNode and endNode, if it exists. Otherwise, null.
   */
  public static ArrayList<Node> callDFS(
      HashMap<String, Node> graph, String startNodeID, String endNodeID) {
    return DFS.traverse(graph.get(startNodeID), graph.get(endNodeID));
  }

  /**
   * @param graph a HashMap<String, Node> (normally) generated by prepDFS() from reading .csv files
   * @param startNodeID the ID of the node where the user wants to start from
   * @param endNodeID the ID of the node that the user wants to get to
   * @return the path between startNode and endNode, if it exists. Otherwise, null.
   */
  public static ArrayList<Node> callAStar(
      HashMap<String, Node> graph, String startNodeID, String endNodeID) {
    return AStar.traverse(graph.get(startNodeID), graph.get(endNodeID));
  }
}
