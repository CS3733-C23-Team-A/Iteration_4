package edu.wpi.cs3733.C23.teamA.controllers;

import edu.wpi.cs3733.C23.teamA.pathfinding.*;
import java.io.IOException;
import java.util.*;

public class PathfindingController {

  /**
   * @return a HashMap<String, Node> representing a graph, read from .csv files
   * @throws IOException if the files cannot be read
   */
  public static HashMap<String, Node> prepGraph() throws IOException {
    // create a graph to hold the L1 information
    HashMap<String, Node> graph = new HashMap<>();

    // add the L1 CSV information to the graph (TO BE UPDATED LATER)
    CSVReader.readNodes("src/main/resources/edu/wpi/cs3733/C23/teamA/mapCSV/L1Nodes.csv", graph);
    CSVReader.readEdges("src/main/resources/edu/wpi/cs3733/C23/teamA/mapCSV/L1Edges.csv", graph);

    return graph;
  }

  /**
   * @param graph a HashMap<String, Node> (normally) generated by prepDFS() from reading .csv files
   * @param startNodeID the ID of the node where the user wants to start from
   * @param endNodeID the ID of the node that the user wants to get to
   * @return the path between startNode and endNode, if it exists. Otherwise, null.
   */
  public static ArrayList<Node> callDFS(
      HashMap<String, Node> graph, String startNodeID, String endNodeID) {
    return DFS.traverse(graph.get(startNodeID), graph.get(endNodeID));
  }

  /**
   * @param graph a HashMap<String, Node> (normally) generated by prepDFS() from reading .csv files
   * @param startNodeID the ID of the node where the user wants to start from
   * @param endNodeID the ID of the node that the user wants to get to
   * @return the path between startNode and endNode, if it exists. Otherwise, null.
   */
  public static ArrayList<Node> callAStar(
      HashMap<String, Node> graph, String startNodeID, String endNodeID) {
    return AStar.traverse(graph.get(startNodeID), graph.get(endNodeID));
  }

  /**
   * After a search has successfully been executed, this method is called to get the path between
   * startNode and endNode.
   *
   * @param startNode Node that the search begins at
   * @param endNode Node that the search ends at or looks for
   * @return the path from the starting node to the ending node
   */
  public static ArrayList<Node> getPath(Node startNode, Node endNode) {
    // initialize the ArrayList which will contain all the Nodes present in the path, and add the
    // ending node to it
    ArrayList<Node> path = new ArrayList<>();

    // Check if startNode and endNode are the same. If they are, return the path with one Node
    if (startNode.equals(endNode)) {
      path.add(startNode);
      return path;
    }

    // Check if endNode even has a parent. If not, something is definitely wrong; throw an error.
    if (endNode.getParent() == null) {
      throw new NullPointerException(
          "Error: The ending node (endNode) specified has no parent, so it is not reachable.");
    }

    // add the ending node to the path, which exists
    path.add(endNode);
    // create a tracker "node" to go through the path created by parent relationships
    Node tracker = endNode;

    // loop until the startNode is found as a parent
    while (!tracker.getParent().equals(startNode)) {
      tracker = tracker.getParent();
      path.add(tracker);
    }

    // add the start node to the list
    path.add(startNode);

    // reverse the path (because it is currently backwards) and return it
    Collections.reverse(path);
    return path;
  }

  /**
   * Prints the path specified by the parameter path. Prints each node with their ID and long name.
   * Implies that the path being given is not null or empty, and has at least two nodes.
   *
   * @param path An ArrayList which represents a path from the node in index zero to the node in the
   *     last index
   */
  public static void printPath(ArrayList<Node> path) {
    // get the first and last node names to print
    String startID = path.get(0).getNodeID();
    String endID = path.get(path.size() - 1).getNodeID();
    System.out.println("Path from " + startID + " to " + endID + ":");

    // loop through all of them to print the full path
    for (Node n : path) {
      System.out.print("Node ID: " + n.getNodeID());
      if (n.getLongName() != null) {
        System.out.println("; Long Name: " + n.getLongName());
      }
    }
  }
}
